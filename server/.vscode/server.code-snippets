{
	"New Model": {
		"prefix": ["newModel"],
		"body": [
			"import { MessengerFunction } from \"../../Messenger\";",
			"import { Model } from \"../../core/Model\";",
			"import IdCreator from \"../IdCreator\";",
			"",
			"type $1Data = {",
			"\t// TODO",
			"};",
			"",
			"class $1 extends Model<$1Data> {",
				"\t",
				"\tstatic ROLE = \"$2\";",
				"",
				"\tstatic create(data: $1Data, domain: string, say: MessengerFunction) : $1 {",
					"\t\tconst repository = IdCreator.createRepoId($1Repo.REPO_NAME, domain);",
					"\t\tconst core = { repository, role: $1.ROLE, data };",
					"\t\treturn new $1(core);",
				"\t}",
				"\t",
			"}",
			"",
			"export { $1 };",
			"export type { $1Data };",
			""
		],
		"description": "New Backend model"
	},
	"New Branch Model": {
		"prefix": ["newBranchModel"],
		"body": [
			"import { MessengerFunction } from \"../../Messenger\";",
			"import { Model } from \"../../core/Model\";",
			"import IdCreator from \"../IdCreator\";",
			"",
			"type $1Data = {",
			"\t// TODO",
			"};",
			"",
			"class $1 extends Model<$1Data> {",
				"\t",
				"\tstatic ROLE = \"$2\";",
				"",
				"\tstatic create(data: $1Data, domain: string, branch: string, say: MessengerFunction) : $1 {",
					"\t\tconst repository = IdCreator.createBranchedRepoId($1Repo.REPO_NAME, branch, domain);",
					"\t\tconst core = { repository, role: $1.ROLE, data };",
					"\t\treturn new $1(core);",
				"\t}",
				"\t",
			"}",
			"",
			"export { $1 };",
			"export type { $1Data };",
			""
		],
		"description": "New Backend model"
	},
	"New Repository": {
		"prefix": ["newRepository"],
		"body": [
			"import { Filter } from \"./types/Filter\";",
			"import { ModelCore } from \"../core/Model\";",
			"import { MessengerFunction } from \"../Messenger\";",
			"import MongoCollection from \"../mongo/MongoCollection\";",
			"import { OperationStatus } from \"../shared/Function\";",
			"import ObjOverride from \"../shared/Object\";",
			"import { $1, $1Data } from \"./models/$1\";",
			"import IRepository from \"./interfaces/IRepository\";",
			"import { ObjectId } from \"mongodb\";",
			"",
			"class $1Repo implements IRepository<$1Data> {",
				"\tpublic static REPO_NAME = \"$2\";",
				"\tprivate _collection: MongoCollection;",
				"",
				"\tconstructor(newCollection: MongoCollection) {",
					"\t\tthis._collection = newCollection;",
				"\t}",
				"",
				"\tpublic get collection(): MongoCollection { return this._collection }",
				"\tpublic set collection(value: MongoCollection) { this._collection = value }",
				"",
				"\tpublic static create(collection: MongoCollection) {",
					"\t\treturn new $1Repo(collection);",
				"\t}",
				"",
				"\tpublic static getInstance(say: MessengerFunction) : $1Repo {",
					"\t\treturn say(this, \"ask\", $1.ROLE + \"Repo\");",
				"\t}",
				"",
				"\tpublic static createQueryFromFilter(filter: Filter | undefined): Dictionary {",
					"\t\treturn MongoQuery.create(filter);",
				"\t}",
				"",
				"\tpublic async add(model: $1, say: MessengerFunction): Promise<OperationStatus> {",
					"\t\tconst insertedId = await this._collection.insertOne(model);",
					"\t\tif (!insertedId) return \"failure\";",
					"",
					"\t\tmodel.id = insertedId;",
					"\t\treturn \"success\";",
				"\t}",
				"",
				"\tpublic addMany(coreArr: ModelCore<$1Data>[], say: MessengerFunction): Promise<OperationStatus> {",
					"\t\treturn this._collection.insertMany(coreArr);",
				"\t}",
				"",
				"\tpublic edit(id: string, model: $1, say: MessengerFunction): Promise<OperationStatus> {",
					"\t\treturn this._collection.updateOne({ _id: new ObjectId(id) }, model);",
				"\t}",
				"",
				"\tpublic get(filter: Filter, say: MessengerFunction): Promise<ModelCore<$1Data>> {",
					"\t\tthrow new Error(\"Method not implemented.\");",
				"\t}",
				"",
				"\tpublic getMany(say: MessengerFunction, filter: Filter | undefined, say: MessengerFunction): Promise<ModelCore<$1Data>[]> {",
					"\t\tconst query = $1Repo.createQueryFromFilter(filter);",
					"\t\treturn this._collection.getMany(query);",
				"\t}",
				"",
				"\tpublic remove(id: string, say: MessengerFunction): Promise<OperationStatus> {",
					"\t\treturn this._collection.deleteMany({ _id: new ObjectId(id) });",
				"\t}",
				"",
				"\tpublic async findById(id: string) : Promise<$1 | null> {",
					"\t\tif (!ObjectId.isValid(id)) return null;",
					"",
					"\t\tconst query = { _id: new ObjectId(id) };",
					"\t\tconst $3Core = await this._collection.findOne(query);",
					"\t\tif (!$3Core) return null;",
					"",
					"\t\treturn new $1($3Core);",
				"\t}",
				"",
				"\tpublic async findByName(name: string): Promise<ModelCore<$1Data> | null> {",
					"\t\tconst query = { \"data.name\": name };",
					"\t\tconst $3Core = await this._collection.findOne(query);",
					"\t\tif (!branchCore) return null;",
					"",
					"\t\treturn new Branch(branchCore);",
				"\t}",
			"}",
			"",
			"export { $1Repo };",
			""
		],
		"description": "New backend Repository."
	},
	"Local messenger": {
		"prefix": ["msngr"],
		"body": [
			"const msngr = (source: Object, purpose: string, what: string, content?: any): any => {",
			"\tif (purpose === \"$1\") {",
			"\t\tif (what === \"$2\") {",
			"\t\t\t$3",
			"\t\t}",
			"\t}",
			"\treturn say(source, purpose, what, content);",
			"}",
		],
		"description": "Standard local messenger function."
	},
	"Is Object Cyclic?": {
		"prefix": ["isCyclic"],
		"body": ["Object.isCyclic = function($0){",
			"\tconst keys = [];",
			"\tconst stack = [];",
			"\tconst stackSet = new Set();",
			"\tlet detected = false;",
		  	"\n",
			"\tfunction detect(object, key){",
				"\t\tif (!(object instanceof Object)) return;",
				"\n",
				"\t\tif (stackSet.has(object)) {",
					"\t\t\tconst oldindex = stack.indexOf(object);",
					"\t\t\tconst l1 = `\\${keys.join(\".\")\\}.\\${key\\}`;",
					"\t\t\tconst l2 = keys.slice(0, oldindex + 1).join(\".\");",
					"\t\t\tconsole.log(`CIRCULAR: \\${l1\\} = \\${l2\\} = \\${object\\}`);",
					"\t\t\tconsole.log(object);",
					"\t\t\tdetected = true;",
					"\t\t\treturn;",
				"\t\t}",
				"\n",
				"\t\tkeys.push(key);",
				"\t\tstack.push(object);",
				"\t\tstackSet.add(object);",
				"\t\tObject.keys(object).forEach(function(k){",
					"\t\t\tif (k && Object.prototype.hasOwnProperty.call(object, k)) {",
						"\t\t\t\tdetect(object[k], k);",
					"\t\t\t}",
				"\t\t});",
				"\n",
				"\t\tkeys.pop();",
				"\t\tstack.pop();",
				"\t\tstackSet.delete(object);",
			"\t}",
			"\n",
			"\tdetect(obj, \"obj\");",
			"\treturn detected;",
		"};"
	],
	"description": "Prints stacktrace if object is cyclic."
	}
}
